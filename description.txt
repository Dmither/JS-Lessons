F12 - відкрити панель розробника в браузері

Код на JS пишеться в Head або вкінці Body (рекомендовано) напряму
    або підключенням файлу js (<script src='script.js'></script>)

console.log(); - команда виводу на консоль

Кожна команда починається із нового рядка та закінчуватись ";"
Для підключення нових функцій спочатку підключаємо строгий режим
    "use strict", який забороняє об'яву змінних без ключового слова

Об'ява змінної:
    let - КС об'яви змінної (lowCamelCase)
    var - КС змінної, яку видно поза блоком кода (крім ф-цій)
    const - КС об'яви константи (постійної, незмінної) (UPPER_CASE)

JS - динамічно-типізована МП, тип змінної міняється в процесі
    undefined - невизначена змінна (неініціалізована)
    null - визначена змінна без інформації
    boolean - змінна логічного типу (true / false)
    number - цілі та дробові числа (Infinity, -Infinity, NaN)
    bigInt - дуже великі числа (1234567890123456789n)
    string - строкова змінна ("" '' ``)
    object - змінна складної строки ({name: "", age: 23})
    symbol - унікальний ідентифікатор об'єкта
    function - споріднений до object тип для об'яви ф-цій
typeof(variable) - поверне тип змінної
Явне перетворення змінних відбувається за доп. одноіменних ф-цій:
    let str22 = String(22);     let num22 = Number(str22);

Оператори: математичні, присвоєння, порівняльні, логічні
    математичні "+" "-" "*" "/" "%" "**";
        (бінарний "+" зі строкою - конкатенація 2+"2"="22" "4"-2=2
        всі інші оператори працюють з числами   22+""="22"  +"2"=2
    присвоєння: "=" "+=" "-=" "*=" "/=" "%=" "++" "--"
        (інкремент та дикремент працює лише зі змінними)
    порівняння: ">" ">=" "<" "<=" "==" "!=" "===" "!=="
        (порівняння строк посимвольно в алфавітному порядку; А < а;
        порівняння різних типів з числами приводить їх до числа;
        строге порівняння порівнює без приведення типів;
        undefined == null; undefined !== null)
    логічні: "&&" "||" "!" "??"
        (при двох нелогічних || поверне першу true, && - останню
        true або першу false: 24 || 46 = 24; 45 && 24 = 24;
        нелогічні з ! переводяться в логічні; !! перетворює в бул;
        ?? повертає перший, якщо він не undefined або null)

Умовні оператори: if, else, else if, ?
    (використання "?":  {res = (boolean) ? firstRes : secondRes} )

Цикли: while, do...while, for
    робота цикла for (let i = 0; i < 5; i++){}; 
    break та continue керує потоком в циклі;
    для переривання верхнього цикла з нижнього ставиться мітка:
        markName: for (;;){
            for(;;){
                break markName;
                }
            }

Цикл перебору (foreach) проходить по черзі всі об'єкти масива:
    for (let item in arr){}

Функції об'являються за допомогою function або ф-ціонального виразу
    називаються як дієсловоПредмет (showMessage)
    Об'ява ф-ції: function funcName([params]){return}
        може бути визвана до об'яви
    Ф-й вираз: let funcName = function([params]){return};
        може бути визвана поза блоком кода
    Ф-я-стрілка: let funcName = ([params]) => return;
        підвид ф-го виразу

Планування ф-й: setTimeout та setInterval
    ф-ї setTimeout та setInterval відкладають лише цільову ф-ю,
        що не впливає на основний потік виконання
    setTimeout(func, time, [params]) - викликає разово через time
        setTimeout(showMessage, 3000, "message") - 
            showMessage("message") через 3000мс (3с)
    clearTimeout(variable) - зупиняє таймер, присвоєний змінній 
    setInterval(func, time, [params]) - багаторазово через time
        більш точну затримку дає рекурсивний setTimeout
    clearInterval(variable) - зупиняє інтервал

Створення та використання об'єкта:
    конструктор об'єкта:    new Object();
    літерал об'єкта:        {};
    Властивості об'єкта {key: value, name: "Carl", age: 30,};
    До всього об'єкта звертаються за іменем (console.log(obj));
    До поля об'єкта по імені.полю або імені[полю]
        Для визова поля можна використовувати змінну з іменем поля:
            let key = "name";
            console.log(obj[key]);
    Додавання полів об'єкту можна ініціалізацією obj.sex = male;
    Видалення поля - delete obj.sex;
    Зміна значення поля - obj.name = newName;
    Копія об'єкта, копія полів об'єкта, дописування полями іншого:
        Object.assign(кінцевий об'єкт, об'єкт або поля для копіювання)
    Перевірка наявності поля: 
        if(obj.name) - при відсутності (або undefined) поверне false
        if("name" in obj) - true при наявності (навіть при undefined)
        obj?.address?.street - перевіряє наявність по ланцюгу
        for(let key in obj) - дасть перебор по всім полям
    Додавання ф-ї в об'єкт: funcName: function(){} або funcName(){}
    Визов ф-ї об'єкта: obj.funcName();
    Слово this вказує на першого предка: cl(this.name) поверне
        поле name, розташоване на рівні поряд з ф-ю;
        стрілкові ф-ції не створюють вкладений рівень
    Конструктори об'єкта - функції для створення об'єкта:
        function User(name, age){
            this.name = name;
            this.age = age;
        }
        Імена конструкторів пишуться з великої літери, визов з new

Запис та використання чисел: 1000, 1e3, 0xff, 0o337, 0b11111111
    метод num.toString(base) перетворює число в строку з базою base
        (num = 255; num.toString(16); //ff)
    Округлення чисел:
        Math.floor округляє до меншого (3.3 = 3; -2.2 = -3)
        Math.ceil - в більшу (3.3 = 4; -2.2 = -2)
        Math.round - до найближчого цілого (3.3 = 3; -2.2 = -2)
        num.toFixed(x) до x символів після крапки, повертає строку
    Проблему з округленням можна вирішити, додавши Number.EPSILON
    Перевірка isNaN(num) та isFinite(num) визначає звичайне число
    parseInt("250.5px") = 250, parseFloor("250.5px") = 250.5
        строка має починатись із числа, можна вказати базу (25px, 2)
    Ф-ї Math:
        Math.random повертає число [0; 1)
        Math.max([numArray]) - максимальне серед переданих 
        Math.min([numArray]) - мінімальне
        Math.abs(num) - мадуль числа
        Math.pow(n, m) - число n в ступіні m

Строки - будь-які текстові дані: 'string' "string" `string`
    Строки в `` мають кілька додаткових можливостей:
        форматування строки `sum: ${calcSum(4, 8)};
        багатостроковий запис, який виведеться так само.
    text.length - довжина строки
    text[n] - поверне n-й символ строки
    робота з кожним символом послідовно: for(const char of text){}
    Строки незмінні: text[n] = char не змінить text
    Зміна реєстру: text.toUpperCase() виведе в верхньому,
        toLowerCase() - в нижньому і т.д.
    Пошук: text.indexOf('sbstr') - позицію першого sbstr (або -1);
        indexOf(sbstr, pos) - починаючи з позиції;
        includes(sbstr, *pos) - бул чи входить;
        startsWith(s), endsWith(s) починається або закінчується s;
    Частина строки: text.slice(a, b) підстрока [a: b), можна від'ємні

Масиви - окремий вид об'єктів, що вміщає в собі певні об'єкти
    Об'ява масиву: new Array(); []; ["first", "second", 33,]
    Отримати значення: arr[n], outOfRange поверне undefined
    Звернутися до ф-ї як до елемента масива: arr[n]();
    Звернутися до елемента багатовимірного масиву: arr[n][m]...;
    arr.length - довжина масиву
    Зміна елемента: arr[n] = obj;
    Додавання в кінець: arr[arr.length] = obj
Матоди масива:
    Додавання, видалення, заміна:
        .push - додавання в кінець
        .pop - видалення останнього елементу
        .shift - видалення першого елементу
        .unshift - додає елемент на початок
        delete arr[n] - затирає значення
        .splice(pos, len *[obj]) - видаляє len елем, починаючи з pos
            повертає видалене, *заміняє на [obj]
    Копія масива:
        .slice(*start, *end) - копія масива *[start: end)
        .concat(obj, [obj]) - копіює з можливістю додавання
    Пошук по масиву:
        .indexOf, lastIndexOf, includes - аналоги строкових методів
        .find, findIndex - повертають серед об'єктів за певною умовою
            let res = arr.find(item => item.age === 18);
        .filter - повертає масив об'єктів за певною умовою
    Сортування масиву:
        .sort - сортування на збільшення (як строки)
            для неї можна вказати власну ф-ю порівняння, яка
            повертає (+ / 0 / -) func(a, b){return a - b}
        .reverse - обернений масив
    Array.isArray(arr) - перевіряє, чи масив
    arr.forEach(function) метод перебору масива
    arr.reduce(function) forEach зі збереженням попереднього значення


